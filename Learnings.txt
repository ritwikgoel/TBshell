Fork:
Basically if the pid_t variable is not initiazed then its default value is 0, 
This is why the child of the forked process is 0. => as its literally just does not initialzes

waitpid():
Just waits for another process to execute and then after that continue the exeution.

exec:
This command replaces the current process image executes another process image.
This can be used to run other c programs from a program by calling it.
execvp calls anoher file and executes it (must be on the $PATH)
The first argument is the name of the command(In our case it becomes (args[0]))=> in case of "ls"
The second argument consists of the name of the command and the arguments passed to the command itself. 
It must also be terminated by NULL.
although the current text, data, heap and stack segments of the process are replaced, the process id still remains unchanged, but the program gets overwritten completely.

cd:
Implicit declatations and how to takle them 
int cd(char *path) {
    return chdir(path);
}

Signal handlers:
It does not really create a thread for the signal handler. However, when a signal is delivered, the signal handler asynchronously 
interrupts a thread (in our case the main thread since we have a single threaded application). 
Once interrupted, the signal handler executes its own code, and the thread may resume execution unless the signal 
handler exits the program. The analogy to multiple threads helps to understand the flow of execution.
so if we specify our own signal handler, then while forking even the child gets the same signal handler.
Now lets assume that we specidfy a signal handler before the fork=>such that it ignores the ctrl-c signal handler. then even while we 
are in the child, we wont be able to ctrl-c our way out.
TO avoid this, before we use the execvp command, we reset the ctrl-c signal handler so that in the child, it can exit. Now if this 
does exit, the program control will come to the parent and then it will loop around. 
